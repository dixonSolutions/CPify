#include "updater.h"
#include "config.h"
#include "settings.h"

#include <libsoup/soup.h>
#include <json-glib/json-glib.h>
#include <gio/gio.h>
#include <string.h>

// GitHub API configuration
#define GITHUB_API_BASE "https://api.github.com"
#define GITHUB_REPO_OWNER "dixonSolutions"
#define GITHUB_REPO_NAME "CPify"
#define GITHUB_RELEASES_URL GITHUB_API_BASE "/repos/" GITHUB_REPO_OWNER "/" GITHUB_REPO_NAME "/releases/latest"

// Static soup session for reuse
static SoupSession *g_soup_session = NULL;

// Cached Flatpak detection result (-1 = unchecked, 0 = no, 1 = yes)
static gint g_is_flatpak = -1;

// Update check state
typedef struct {
  CPifyUpdateCallback callback;
  gpointer user_data;
} UpdateCheckData;

// Install state
typedef struct {
  CPifyReleaseInfo *release;
  GtkWindow *parent_window;
  GCallback on_complete;
  gpointer user_data;
  GtkWidget *progress_dialog;
  GtkWidget *progress_bar;
  GtkWidget *status_label;
  GFile *dest_file;
  GInputStream *input_stream;
} InstallData;

void cpify_updater_init(void) {
  if (!g_soup_session) {
    g_soup_session = soup_session_new();
    // Set a user agent as required by GitHub API
    soup_session_set_user_agent(g_soup_session, "CPify-Updater/1.0");
  }
}

void cpify_updater_cleanup(void) {
  if (g_soup_session) {
    g_object_unref(g_soup_session);
    g_soup_session = NULL;
  }
}

const gchar *cpify_updater_get_current_version(void) {
  return CPIFY_VERSION;
}

gboolean cpify_updater_is_flatpak(void) {
  if (g_is_flatpak < 0) {
    // /.flatpak-info exists inside every Flatpak sandbox
    g_is_flatpak = g_file_test("/.flatpak-info", G_FILE_TEST_EXISTS) ? 1 : 0;
    g_print("[UPDATER] Flatpak runtime detected: %s\n", g_is_flatpak ? "yes" : "no");
  }
  return (gboolean)g_is_flatpak;
}

const gchar *cpify_updater_get_os_identifier(void) {
#if defined(__linux__)
  return "linux";
#elif defined(_WIN32) || defined(_WIN64)
  return "windows";
#elif defined(__APPLE__)
  return "macos";
#else
  return "unknown";
#endif
}

static const gchar *get_arch_identifier(void) {
#if defined(__x86_64__) || defined(_M_X64)
  return "x86_64";
#elif defined(__i386__) || defined(_M_IX86)
  return "i386";
#elif defined(__aarch64__) || defined(_M_ARM64)
  return "aarch64";
#elif defined(__arm__) || defined(_M_ARM)
  return "arm";
#else
  return "unknown";
#endif
}

gint cpify_version_compare(const gchar *v1, const gchar *v2) {
  if (!v1 && !v2) return 0;
  if (!v1) return -1;
  if (!v2) return 1;

  // Skip leading 'v' or 'V' if present
  if (*v1 == 'v' || *v1 == 'V') v1++;
  if (*v2 == 'v' || *v2 == 'V') v2++;

  gchar **parts1 = g_strsplit(v1, ".", -1);
  gchar **parts2 = g_strsplit(v2, ".", -1);

  gint result = 0;
  guint i = 0;

  while (parts1[i] || parts2[i]) {
    gint64 n1 = parts1[i] ? g_ascii_strtoll(parts1[i], NULL, 10) : 0;
    gint64 n2 = parts2[i] ? g_ascii_strtoll(parts2[i], NULL, 10) : 0;

    if (n1 < n2) {
      result = -1;
      break;
    } else if (n1 > n2) {
      result = 1;
      break;
    }
    i++;
  }

  g_strfreev(parts1);
  g_strfreev(parts2);
  return result;
}

void cpify_release_info_free(CPifyReleaseInfo *info) {
  if (!info) return;
  g_free(info->tag_name);
  g_free(info->title);
  g_free(info->description);
  g_free(info->download_url);
  g_free(info->published_at);
  g_free(info);
}

static gchar *find_asset_url_for_os(JsonArray *assets) {
  const gchar *os = cpify_updater_get_os_identifier();
  const gchar *arch = get_arch_identifier();

  guint len = json_array_get_length(assets);
  for (guint i = 0; i < len; i++) {
    JsonObject *asset = json_array_get_object_element(assets, i);
    const gchar *name = json_object_get_string_member(asset, "name");
    
    if (!name) continue;

    // Look for binary matching OS and architecture
    // Expected naming: cpify-linux-x86_64, cpify-windows-x86_64.exe, cpify-macos-aarch64
    gchar *name_lower = g_utf8_strdown(name, -1);
    gboolean os_match = g_strstr_len(name_lower, -1, os) != NULL;
    gboolean arch_match = g_strstr_len(name_lower, -1, arch) != NULL;
    g_free(name_lower);

    if (os_match && arch_match) {
      return g_strdup(json_object_get_string_member(asset, "browser_download_url"));
    }
  }

  // Fallback: try to find any matching OS
  for (guint i = 0; i < len; i++) {
    JsonObject *asset = json_array_get_object_element(assets, i);
    const gchar *name = json_object_get_string_member(asset, "name");
    
    if (!name) continue;

    gchar *name_lower = g_utf8_strdown(name, -1);
    gboolean os_match = g_strstr_len(name_lower, -1, os) != NULL;
    g_free(name_lower);

    if (os_match) {
      return g_strdup(json_object_get_string_member(asset, "browser_download_url"));
    }
  }

  return NULL;
}

static CPifyReleaseInfo *parse_release_json(const gchar *json_data, gsize length) {
  JsonParser *parser = json_parser_new();
  GError *error = NULL;

  if (!json_parser_load_from_data(parser, json_data, length, &error)) {
    g_printerr("[UPDATER] Failed to parse JSON: %s\n", error->message);
    g_error_free(error);
    g_object_unref(parser);
    return NULL;
  }

  JsonNode *root = json_parser_get_root(parser);
  if (!JSON_NODE_HOLDS_OBJECT(root)) {
    g_printerr("[UPDATER] Invalid JSON structure\n");
    g_object_unref(parser);
    return NULL;
  }

  JsonObject *obj = json_node_get_object(root);

  CPifyReleaseInfo *info = g_new0(CPifyReleaseInfo, 1);
  info->tag_name = g_strdup(json_object_get_string_member(obj, "tag_name"));
  info->title = g_strdup(json_object_get_string_member(obj, "name"));
  info->description = g_strdup(json_object_get_string_member(obj, "body"));
  info->published_at = g_strdup(json_object_get_string_member(obj, "published_at"));

  // Find appropriate asset for this OS
  if (json_object_has_member(obj, "assets")) {
    JsonArray *assets = json_object_get_array_member(obj, "assets");
    info->download_url = find_asset_url_for_os(assets);
  }

  g_object_unref(parser);
  return info;
}

static void on_update_check_complete(GObject *source, GAsyncResult *result, gpointer user_data) {
  UpdateCheckData *data = (UpdateCheckData *)user_data;
  SoupSession *session = SOUP_SESSION(source);
  GError *error = NULL;
  GBytes *bytes = NULL;

  bytes = soup_session_send_and_read_finish(session, result, &error);

  if (error) {
    g_printerr("[UPDATER] HTTP request failed: %s\n", error->message);
    if (data->callback) {
      data->callback(NULL, error, data->user_data);
    }
    g_error_free(error);
    g_free(data);
    return;
  }

  gsize size;
  const gchar *body = g_bytes_get_data(bytes, &size);

  CPifyReleaseInfo *release = parse_release_json(body, size);
  g_bytes_unref(bytes);

  if (!release) {
    GError *parse_error = g_error_new_literal(G_IO_ERROR, G_IO_ERROR_INVALID_DATA, 
                                               "Failed to parse release data");
    if (data->callback) {
      data->callback(NULL, parse_error, data->user_data);
    }
    g_error_free(parse_error);
    g_free(data);
    return;
  }

  // Compare versions using the compile-time version (always matches this binary)
  const gchar *current = cpify_updater_get_current_version();
  gint cmp = cpify_version_compare(current, release->tag_name);

  g_print("[UPDATER] Runtime: Flatpak=%s, Current version: %s, Latest release: %s (tag: %s), Comparison: %d\n", 
          cpify_updater_is_flatpak() ? "yes" : "no",
          current, release->title, release->tag_name, cmp);

  if (cmp >= 0) {
    // Current version is same or newer -- up to date
    g_print("[UPDATER] No update needed (current is up to date)\n");

    // Clear any previously skipped version since we're now current
    CPifySettings *settings = cpify_settings_get();
    if (settings->skipped_update_version) {
      g_free(settings->skipped_update_version);
      settings->skipped_update_version = NULL;
      cpify_settings_save();
    }

    cpify_release_info_free(release);
    if (data->callback) {
      data->callback(NULL, NULL, data->user_data);
    }
  } else {
    // A newer version exists on GitHub -- check if user already dismissed it
    CPifySettings *settings = cpify_settings_get();
    if (settings->skipped_update_version &&
        cpify_version_compare(settings->skipped_update_version, release->tag_name) >= 0) {
      g_print("[UPDATER] Update %s was previously skipped by user\n", release->tag_name);
      cpify_release_info_free(release);
      if (data->callback) {
        data->callback(NULL, NULL, data->user_data);
      }
    } else {
      g_print("[UPDATER] Update available: %s -> %s\n", current, release->tag_name);
      if (data->callback) {
        data->callback(release, NULL, data->user_data);
      }
    }
  }

  g_free(data);
}

void cpify_updater_check_async(CPifyUpdateCallback callback, gpointer user_data) {
  if (!g_soup_session) {
    cpify_updater_init();
  }

  UpdateCheckData *data = g_new0(UpdateCheckData, 1);
  data->callback = callback;
  data->user_data = user_data;

  SoupMessage *msg = soup_message_new("GET", GITHUB_RELEASES_URL);
  
  SoupMessageHeaders *req_headers = soup_message_get_request_headers(msg);

  // Add Accept header for GitHub API
  soup_message_headers_append(req_headers, "Accept", "application/vnd.github.v3+json");

  // Bypass HTTP caches to get the latest release data
  soup_message_headers_append(req_headers, "Cache-Control", "no-cache");

  g_print("[UPDATER] Checking for updates at %s (current: %s)\n", 
          GITHUB_RELEASES_URL, cpify_updater_get_current_version());

  soup_session_send_and_read_async(g_soup_session, msg, G_PRIORITY_DEFAULT, 
                                    NULL, on_update_check_complete, data);
  g_object_unref(msg);
}

// ============ Update Dialog ============

// Data attached to the dialog for cleanup and button callbacks
typedef struct {
  CPifyReleaseInfo *release;
  GtkWindow *parent_window;
  AdwDialog *dialog;
} DialogData;

static void on_update_dialog_close_clicked(GtkButton *btn, gpointer user_data) {
  (void)btn;
  DialogData *dd = (DialogData *)user_data;
  adw_dialog_close(dd->dialog);
}

// "Skip This Version" -- persist the tag so we never prompt for it again
static void on_update_dialog_skip_clicked(GtkButton *btn, gpointer user_data) {
  (void)btn;
  DialogData *dd = (DialogData *)user_data;

  CPifySettings *settings = cpify_settings_get();
  g_free(settings->skipped_update_version);
  settings->skipped_update_version = g_strdup(dd->release->tag_name);
  cpify_settings_save();

  g_print("[UPDATER] User skipped version %s\n", dd->release->tag_name);
  adw_dialog_close(dd->dialog);
}

static void on_install_complete(GObject *source, GAsyncResult *result, gpointer user_data);

static void on_install_complete(GObject *source, GAsyncResult *result, gpointer user_data) {
  (void)source;
  (void)result;
  InstallData *data = (InstallData *)user_data;
  
  g_print("[UPDATER] Download complete\n");
  
  AdwAlertDialog *dialog = ADW_ALERT_DIALOG(adw_alert_dialog_new(
    "Update Downloaded",
    "The update has been downloaded. Please install the new Flatpak bundle to complete the update."));
  adw_alert_dialog_add_response(dialog, "ok", "OK");
  adw_dialog_present(ADW_DIALOG(dialog), GTK_WIDGET(data->parent_window));
  
  g_free(data);
}

static void on_update_dialog_install_clicked(GtkButton *btn, gpointer user_data) {
  (void)btn;
  InstallData *install_data = (InstallData *)user_data;
  
  gtk_widget_set_sensitive(GTK_WIDGET(btn), FALSE);
  gtk_button_set_label(btn, "Downloading...");
  
  cpify_updater_install_async(install_data->release, 
                               install_data->parent_window,
                               G_CALLBACK(on_install_complete), 
                               install_data);
}

static void dialog_data_free(gpointer user_data) {
  DialogData *dd = (DialogData *)user_data;
  if (dd) {
    cpify_release_info_free(dd->release);
    g_free(dd);
  }
}

GtkWidget *cpify_updater_show_dialog(GtkWindow *parent_window, CPifyReleaseInfo *release) {
  if (!release) return NULL;

  gboolean is_flatpak = cpify_updater_is_flatpak();

  // Create dialog
  AdwDialog *dialog = adw_dialog_new();
  adw_dialog_set_title(dialog, "Update Available");
  adw_dialog_set_content_width(dialog, 480);
  adw_dialog_set_content_height(dialog, 420);

  // Shared dialog data for button callbacks -- freed when dialog is destroyed
  DialogData *dd = g_new0(DialogData, 1);
  dd->release = release;  // Takes ownership
  dd->parent_window = parent_window;
  dd->dialog = dialog;
  g_object_set_data_full(G_OBJECT(dialog), "dialog-data", dd, dialog_data_free);

  // Main content
  GtkWidget *content = gtk_box_new(GTK_ORIENTATION_VERTICAL, 16);
  gtk_widget_set_margin_start(content, 24);
  gtk_widget_set_margin_end(content, 24);
  gtk_widget_set_margin_top(content, 24);
  gtk_widget_set_margin_bottom(content, 24);

  // Header with icon
  GtkWidget *header_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 16);
  gtk_widget_set_halign(header_box, GTK_ALIGN_CENTER);
  
  GtkWidget *icon = gtk_image_new_from_icon_name("software-update-available-symbolic");
  gtk_image_set_pixel_size(GTK_IMAGE(icon), 64);
  gtk_widget_add_css_class(icon, "accent");
  gtk_box_append(GTK_BOX(header_box), icon);

  GtkWidget *title_label = gtk_label_new(NULL);
  gchar *escaped_title = g_markup_escape_text(
    release->title ? release->title : "New Update Available", -1);
  gchar *title_markup = g_strdup_printf(
    "<span size='x-large' weight='bold'>%s</span>", escaped_title);
  gtk_label_set_markup(GTK_LABEL(title_label), title_markup);
  gtk_label_set_wrap(GTK_LABEL(title_label), TRUE);
  g_free(title_markup);
  g_free(escaped_title);
  gtk_box_append(GTK_BOX(header_box), title_label);
  gtk_box_append(GTK_BOX(content), header_box);

  // Version info
  GtkWidget *version_label = gtk_label_new(NULL);
  gchar *version_text = g_strdup_printf("Version %s \u2192 %s", 
                                         cpify_updater_get_current_version(),
                                         release->tag_name);
  gtk_label_set_text(GTK_LABEL(version_label), version_text);
  gtk_widget_add_css_class(version_label, "dim-label");
  g_free(version_text);
  gtk_box_append(GTK_BOX(content), version_label);

  // Description in scrolled window
  GtkWidget *desc_scroll = gtk_scrolled_window_new();
  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(desc_scroll), 
                                  GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
  gtk_widget_set_vexpand(desc_scroll, TRUE);
  gtk_widget_set_size_request(desc_scroll, -1, 150);

  GtkWidget *desc_label = gtk_label_new(
    release->description ? release->description : "No release notes available.");
  gtk_label_set_wrap(GTK_LABEL(desc_label), TRUE);
  gtk_label_set_xalign(GTK_LABEL(desc_label), 0.0f);
  gtk_label_set_yalign(GTK_LABEL(desc_label), 0.0f);
  gtk_label_set_selectable(GTK_LABEL(desc_label), TRUE);
  gtk_scrolled_window_set_child(GTK_SCROLLED_WINDOW(desc_scroll), desc_label);

  GtkWidget *desc_frame = gtk_frame_new(NULL);
  gtk_widget_add_css_class(desc_frame, "view");
  gtk_frame_set_child(GTK_FRAME(desc_frame), desc_scroll);
  gtk_box_append(GTK_BOX(content), desc_frame);

  // Flatpak-specific guidance or download availability notice
  if (is_flatpak) {
    GtkWidget *notice = gtk_label_new(NULL);
    gtk_label_set_markup(GTK_LABEL(notice),
      "To update, run in a terminal:\n"
      "<tt>flatpak update com.github.dixonsolutions.CPify</tt>\n"
      "or update through GNOME Software.");
    gtk_label_set_wrap(GTK_LABEL(notice), TRUE);
    gtk_label_set_selectable(GTK_LABEL(notice), TRUE);
    gtk_widget_add_css_class(notice, "dim-label");
    gtk_box_append(GTK_BOX(content), notice);
  } else if (!release->download_url) {
    GtkWidget *notice = gtk_label_new(NULL);
    gtk_label_set_markup(GTK_LABEL(notice), 
      "<span color='orange'>No binary available for your system. Please build from source.</span>");
    gtk_label_set_wrap(GTK_LABEL(notice), TRUE);
    gtk_box_append(GTK_BOX(content), notice);
  }

  // Button box
  GtkWidget *button_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 12);
  gtk_widget_set_halign(button_box, GTK_ALIGN_END);
  gtk_widget_set_margin_top(button_box, 8);

  // "Skip This Version" button -- persists so the user isn't nagged again
  GtkWidget *skip_btn = gtk_button_new_with_label("Skip This Version");
  gtk_widget_set_tooltip_text(skip_btn, "Don't remind me about this version");
  g_signal_connect(skip_btn, "clicked", G_CALLBACK(on_update_dialog_skip_clicked), dd);

  // "Later" button -- dismisses for this session only
  GtkWidget *close_btn = gtk_button_new_with_label("Later");
  g_signal_connect(close_btn, "clicked", G_CALLBACK(on_update_dialog_close_clicked), dd);

  gtk_box_append(GTK_BOX(button_box), skip_btn);
  gtk_box_append(GTK_BOX(button_box), close_btn);

  // Only show "Install Update" / "Download" for non-Flatpak builds
  if (!is_flatpak) {
    GtkWidget *install_btn = gtk_button_new_with_label("Install Update");
    gtk_widget_add_css_class(install_btn, "suggested-action");

    InstallData *install_data = g_new0(InstallData, 1);
    install_data->release = release;
    install_data->parent_window = parent_window;

    if (release->download_url) {
      g_signal_connect(install_btn, "clicked", 
                       G_CALLBACK(on_update_dialog_install_clicked), install_data);
    } else {
      gtk_widget_set_sensitive(install_btn, FALSE);
      gtk_widget_set_tooltip_text(install_btn, "No binary available for your OS");
    }

    gtk_box_append(GTK_BOX(button_box), install_btn);
  }

  gtk_box_append(GTK_BOX(content), button_box);

  adw_dialog_set_child(dialog, content);
  adw_dialog_present(dialog, GTK_WIDGET(parent_window));

  return GTK_WIDGET(dialog);
}

static void on_splice_complete(GObject *source, GAsyncResult *result, gpointer user_data) {
  GOutputStream *out = G_OUTPUT_STREAM(source);
  InstallData *data = (InstallData *)user_data;
  GError *error = NULL;

  gssize transferred = g_output_stream_splice_finish(out, result, &error);
  
  if (transferred < 0) {
    g_printerr("[UPDATER] Download splice failed: %s\n", error->message);
    AdwAlertDialog *dialog = ADW_ALERT_DIALOG(adw_alert_dialog_new(
      "Download Failed",
      error->message));
    adw_alert_dialog_add_response(dialog, "ok", "OK");
    adw_dialog_present(ADW_DIALOG(dialog), GTK_WIDGET(data->parent_window));
    g_error_free(error);
    g_free(data); // In a real app we might want to free streams/files too if not closed
    return;
  }

  g_print("[UPDATER] Download complete, transferred %zd bytes\n", transferred);

  // Make the downloaded file executable
  if (data->dest_file) {
    GFileInfo *info = g_file_query_info(data->dest_file, G_FILE_ATTRIBUTE_UNIX_MODE, 
                                         G_FILE_QUERY_INFO_NONE, NULL, NULL);
    if (info) {
      guint32 mode = g_file_info_get_attribute_uint32(info, G_FILE_ATTRIBUTE_UNIX_MODE);
      mode |= 0755;  // Add executable permissions
      g_file_set_attribute_uint32(data->dest_file, G_FILE_ATTRIBUTE_UNIX_MODE, mode, 
                                   G_FILE_QUERY_INFO_NONE, NULL, NULL);
      g_object_unref(info);
    }
  }

  // Cleanup references
  if (data->input_stream) g_object_unref(data->input_stream);
  if (data->dest_file) g_object_unref(data->dest_file);
  
  // Forward to completion handler
  on_install_complete(NULL, NULL, data);
}

static void on_file_replace_complete(GObject *source, GAsyncResult *result, gpointer user_data) {
  GFile *file = G_FILE(source);
  InstallData *data = (InstallData *)user_data;
  GError *error = NULL;

  GFileOutputStream *out = g_file_replace_finish(file, result, &error);
  if (!out) {
    g_printerr("[UPDATER] Failed to open file for writing: %s\n", error->message);
    if (data->input_stream) g_object_unref(data->input_stream);
    // Error handling UI...
    g_error_free(error);
    return;
  }

  // Splice input content to file
  g_output_stream_splice_async(G_OUTPUT_STREAM(out), data->input_stream,
                                G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE | G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET,
                                G_PRIORITY_DEFAULT, NULL,
                                on_splice_complete, data);
  g_object_unref(out); // The async splice holds a ref
}

static void on_soup_send_complete(GObject *source, GAsyncResult *result, gpointer user_data) {
  SoupSession *session = SOUP_SESSION(source);
  InstallData *data = (InstallData *)user_data;
  GError *error = NULL;

  GInputStream *in = soup_session_send_finish(session, result, &error);
  if (!in) {
    g_printerr("[UPDATER] HTTP download request failed: %s\n", error->message);
    g_error_free(error);
    // Show error UI
    return;
  }
  
  data->input_stream = in;

  // Open destination file
  g_file_replace_async(data->dest_file, 
                        NULL, 
                        FALSE, 
                        G_FILE_CREATE_REPLACE_DESTINATION, 
                        G_PRIORITY_DEFAULT, 
                        NULL, 
                        on_file_replace_complete, 
                        data);
}

void cpify_updater_install_async(CPifyReleaseInfo *release, 
                                  GtkWindow *parent_window,
                                  GCallback on_complete, 
                                  gpointer user_data) {
  if (!release || !release->download_url) {
    g_printerr("[UPDATER] No download URL available\n");
    return;
  }

  InstallData *data = g_new0(InstallData, 1);
  data->release = release;
  data->parent_window = parent_window;
  data->on_complete = on_complete;
  data->user_data = user_data;

  const gchar *cache_dir = g_get_user_cache_dir();
  gchar *download_dir = g_build_filename(cache_dir, "cpify", "updates", NULL);
  g_mkdir_with_parents(download_dir, 0755);

  gchar *basename = g_path_get_basename(release->download_url);
  gchar *dest_path = g_build_filename(download_dir, basename, NULL);
  
  data->dest_file = g_file_new_for_path(dest_path);
  
  g_print("[UPDATER] Downloading %s to %s with libsoup\n", release->download_url, dest_path);

  g_free(basename);
  g_free(download_dir);
  g_free(dest_path);

  SoupMessage *msg = soup_message_new("GET", release->download_url);
  
  // Use existing session
  if (!g_soup_session) cpify_updater_init();
  
  soup_session_send_async(g_soup_session, msg, G_PRIORITY_DEFAULT, 
                           NULL, on_soup_send_complete, data);
  g_object_unref(msg);
}
